<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Q*bert Quest - Free HTML5 Game | GameZone99</title>
    <meta name="description" content="Jump your way to victory in Q*bert Quest! Classic arcade puzzle game with modern twists. Change all pyramid blocks while avoiding enemies. Mobile-friendly browser game.">
    <meta name="keywords" content="qbert game, puzzle game, arcade game, html5 game, browser game, mobile game, pyramid puzzle">
    <meta name="author" content="GameZone99">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://gameszone99.com/games/qbert-quest.html">
    <meta property="og:title" content="Q*bert Quest - Free HTML5 Game">
    <meta property="og:description" content="Jump your way to victory in this classic arcade puzzle game!">
    <meta property="og:image" content="https://gameszone99.com/assets/qbert-quest-og.jpg">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://gameszone99.com/games/qbert-quest.html">
    <meta property="twitter:title" content="Q*bert Quest - Free HTML5 Game">
    <meta property="twitter:description" content="Jump your way to victory in this classic arcade puzzle game!">
    <meta property="twitter:image" content="https://gameszone99.com/assets/qbert-quest-og.jpg">

    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --dark-gradient: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 100%);
            --accent-color: #00d4ff;
            --success-color: #00ff88;
            --warning-color: #ffaa00;
            --danger-color: #ff4757;
            --text-primary: #ffffff;
            --text-secondary: #b8c1ec;
            --card-bg: rgba(255, 255, 255, 0.05);
            --card-border: rgba(255, 255, 255, 0.1);
            --shadow-glow: 0 0 40px rgba(0, 212, 255, 0.3);
            --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: "Inter", sans-serif;
            background: var(--dark-gradient);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Ad Containers */
        .ad-container-top, .ad-container-bottom {
            width: 100%;
            min-height: 90px;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid var(--card-border);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .ad-container-bottom {
            position: static;
            border-top: 1px solid var(--card-border);
            border-bottom: none;
            margin-top: auto;
        }

        .ad-placeholder {
            width: 728px;
            height: 90px;
            background: linear-gradient(45deg, #333, #555);
            border: 2px dashed #666;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 14px;
            border-radius: 8px;
        }

        /* Header */
        .header {
            padding: 1rem 0;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--card-border);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        .header h1 {
            font-family: 'Orbitron', monospace;
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            font-weight: 900;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 0.5rem;
        }

        .header p {
            text-align: center;
            color: var(--text-secondary);
            font-size: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            padding: 2rem 0;
        }

        .game-container {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 2rem;
            align-items: start;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        /* Game Area */
        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .game-board {
            background: var(--card-bg);
            border: 2px solid var(--card-border);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            position: relative;
            width: 500px;
            height: 500px;
            box-shadow: var(--shadow-card);
            overflow: hidden;
        }

        .pyramid-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .cube {
            position: absolute;
            width: 32px;
            height: 32px;
            background: #666;
            border: 2px solid #888;
            border-radius: 4px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .cube.active { 
            background: var(--accent-color); 
            border-color: var(--success-color); 
        }
        
        .cube.target { 
            background: var(--success-color); 
            border-color: #fff; 
            box-shadow: 0 0 20px var(--success-color); 
        }

        .character {
            position: absolute;
            width: 24px;
            height: 24px;
            background: var(--secondary-gradient);
            border-radius: 50%;
            border: 3px solid #fff;
            transition: all 0.2s ease;
            z-index: 10;
            box-shadow: 0 0 15px rgba(240, 147, 251, 0.5);
        }

        .enemy {
            position: absolute;
            width: 20px;
            height: 20px;
            background: var(--danger-color);
            border-radius: 4px;
            border: 2px solid #fff;
            transition: all 0.3s ease;
            z-index: 9;
        }

        /* Game Controls */
        .game-status {
            display: flex;
            gap: 2rem;
            margin-bottom: 1rem;
        }

        .status-item {
            text-align: center;
            background: var(--card-bg);
            padding: 1rem;
            border-radius: 10px;
            border: 1px solid var(--card-border);
            backdrop-filter: blur(10px);
            min-width: 100px;
        }

        .status-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.5rem;
        }

        .status-value {
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-color);
        }

        .game-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-button {
            padding: 12px 20px;
            background: var(--primary-gradient);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-card);
        }

        .control-button.start-game {
            background: var(--success-color);
            font-size: 1.1rem;
            padding: 15px 30px;
        }

        .control-button.new-game {
            background: var(--warning-color);
        }

        /* Touch Controls */
        .touch-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 1rem;
            max-width: 200px;
        }

        .touch-btn {
            background: var(--card-bg);
            border: 2px solid var(--card-border);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 1.2rem;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .touch-btn:hover, .touch-btn:active {
            background: var(--accent-color);
            transform: scale(0.95);
        }

        .touch-btn:nth-child(1) { grid-column: 2; } /* Up */
        .touch-btn:nth-child(2) { grid-column: 1; grid-row: 2; } /* Left */
        .touch-btn:nth-child(3) { grid-column: 3; grid-row: 2; } /* Right */
        .touch-btn:nth-child(4) { grid-column: 2; grid-row: 2; } /* Down */

        /* Sidebar */
        .game-info {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 15px;
            padding: 1.5rem;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }

        .game-info h3 {
            font-family: 'Orbitron', monospace;
            color: var(--accent-color);
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .game-info ul {
            list-style: none;
            margin-bottom: 1.5rem;
        }

        .game-info li {
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .game-info li:before {
            content: "‚ñ∂";
            color: var(--accent-color);
            margin-right: 0.5rem;
        }

        /* Game Over Modal */
        .game-over-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: var(--card-bg);
            border: 2px solid var(--card-border);
            border-radius: 20px;
            padding: 2rem;
            text-align: center;
            backdrop-filter: blur(20px);
            max-width: 400px;
            width: 90%;
        }

        .modal-content h2 {
            font-family: 'Orbitron', monospace;
            font-size: 2rem;
            margin-bottom: 1rem;
            background: var(--secondary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .modal-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .modal-stat {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 10px;
        }

        .modal-stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .modal-stat-value {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            color: var(--accent-color);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .ad-placeholder {
                width: 320px;
                height: 50px;
            }

            .game-container {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .game-board {
                width: 350px;
                height: 350px;
                padding: 15px;
            }

            .cube {
                width: 22px;
                height: 22px;
            }

            .character {
                width: 18px;
                height: 18px;
            }

            .enemy {
                width: 16px;
                height: 16px;
            }

            .game-status {
                flex-direction: column;
                gap: 1rem;
            }

            .touch-controls {
                display: grid;
            }
        }

        @media (max-width: 480px) {
            .game-board {
                width: 300px;
                height: 300px;
            }

            .cube {
                width: 18px;
                height: 18px;
            }

            .character {
                width: 14px;
                height: 14px;
            }

            .enemy {
                width: 12px;
                height: 12px;
            }
        }

        /* Animations */
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        .character.jumping {
            animation: bounce 0.3s ease;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .cube.changing {
            animation: pulse 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Top Ad Container -->
    <div class="ad-container-top">
        <div class="ad-placeholder">Advertisement Space - 728x90</div>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="container">
            <h1>Q*bert Quest</h1>
            <p>Jump your way to victory! Change all pyramid blocks to complete each level.</p>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
        <div class="game-container">
            <!-- Game Info Sidebar -->
            <div class="game-info">
                <h3>How to Play</h3>
                <ul>
                    <li>Use arrow keys or touch controls to move</li>
                    <li>Jump on cubes to change their color</li>
                    <li>Change all cubes to target color</li>
                    <li>Avoid red enemies</li>
                    <li>Don't fall off the pyramid!</li>
                </ul>
                
                <h3>Power-ups</h3>
                <ul>
                    <li>üü¢ Green orbs slow down enemies</li>
                    <li>‚≠ê Stars give bonus points</li>
                    <li>‚ùÑÔ∏è Ice freezes enemies briefly</li>
                </ul>
            </div>

            <!-- Game Area -->
            <div class="game-area">
                <div class="game-status">
                    <div class="status-item">
                        <div class="status-label">Score</div>
                        <div class="status-value" id="score">0</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Level</div>
                        <div class="status-value" id="level">1</div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Lives</div>
                        <div class="status-value" id="lives">3</div>
                    </div>
                </div>

                <div class="game-board" id="gameBoard">
                    <div class="pyramid-container" id="pyramidContainer">
                        <!-- Game elements will be inserted here -->
                    </div>
                </div>

                <div class="game-controls">
                    <button class="control-button start-game" id="startBtn">Start Game</button>
                    <button class="control-button new-game" id="newGameBtn" style="display: none;">New Game</button>
                </div>

                <!-- Touch Controls for Mobile -->
                <div class="touch-controls" id="touchControls" style="display: none;">
                    <button class="touch-btn" data-direction="up">‚Üñ</button>
                    <button class="touch-btn" data-direction="left">‚Üô</button>
                    <button class="touch-btn" data-direction="down">‚Üò</button>
                    <button class="touch-btn" data-direction="right">‚Üó</button>
                </div>
            </div>

            <!-- Empty space for layout balance -->
            <div></div>
        </div>
    </main>

    <!-- Game Over Modal -->
    <div class="game-over-modal" id="gameOverModal">
        <div class="modal-content">
            <h2 id="gameOverTitle">Game Over!</h2>
            <div class="modal-stats">
                <div class="modal-stat">
                    <div class="modal-stat-label">Final Score</div>
                    <div class="modal-stat-value" id="finalScore">0</div>
                </div>
                <div class="modal-stat">
                    <div class="modal-stat-label">Level Reached</div>
                    <div class="modal-stat-value" id="finalLevel">1</div>
                </div>
                <div class="modal-stat">
                    <div class="modal-stat-label">Best Score</div>
                    <div class="modal-stat-value" id="bestScore">0</div>
                </div>
                <div class="modal-stat">
                    <div class="modal-stat-label">Cubes Changed</div>
                    <div class="modal-stat-value" id="cubesChanged">0</div>
                </div>
            </div>
            <div class="game-controls">
                <button class="control-button start-game" id="playAgainBtn">Play Again</button>
                <button class="control-button" id="closeModalBtn">Close</button>
            </div>
        </div>
    </div>

    <!-- Bottom Ad Container -->
    <div class="ad-container-bottom">
        <div class="ad-placeholder">Advertisement Space - 728x90</div>
    </div>

    <script>
        class QbertGame {
            constructor() {
                this.gameBoard = document.getElementById('gameBoard');
                this.pyramidContainer = document.getElementById('pyramidContainer');
                this.scoreElement = document.getElementById('score');
                this.levelElement = document.getElementById('level');
                this.livesElement = document.getElementById('lives');
                
                this.score = 0;
                this.level = 1;
                this.lives = 3;
                this.gameRunning = false;
                this.gameStarted = false;
                
                this.playerPos = { row: 0, col: 0 };
                this.enemies = [];
                this.powerUps = [];
                this.cubesChanged = 0;
                
                this.pyramidSize = 6; // Reduced from 7 to fit better
                this.cubes = [];
                this.targetColor = '#00ff88';
                this.normalColor = '#666';
                
                this.enemySpeed = 2000;
                this.powerUpSpawnRate = 15000;
                
                this.initializeGame();
                this.setupEventListeners();
                this.loadBestScore();
            }

            initializeGame() {
                this.createPyramid();
                this.createPlayer();
                this.updateDisplay();
            }

            setupEventListeners() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (!this.gameRunning) return;
                    
                    switch(e.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            e.preventDefault();
                            this.movePlayer('up');
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            e.preventDefault();
                            this.movePlayer('down');
                            break;
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            e.preventDefault();
                            this.movePlayer('left');
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            e.preventDefault();
                            this.movePlayer('right');
                            break;
                    }
                });

                // Touch controls
                document.querySelectorAll('.touch-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        if (!this.gameRunning) return;
                        e.preventDefault();
                        const direction = btn.dataset.direction;
                        this.movePlayer(direction);
                    });
                });

                // Game control buttons
                document.getElementById('startBtn').addEventListener('click', () => this.startGame());
                document.getElementById('newGameBtn').addEventListener('click', () => this.resetGame());
                document.getElementById('playAgainBtn').addEventListener('click', () => this.resetGame());
                document.getElementById('closeModalBtn').addEventListener('click', () => this.hideGameOver());

                // Touch/mobile detection
                if ('ontouchstart' in window) {
                    document.getElementById('touchControls').style.display = 'grid';
                }
            }

            createPyramid() {
                this.pyramidContainer.innerHTML = '';
                this.cubes = [];

                // Get board dimensions
                const boardRect = this.pyramidContainer.getBoundingClientRect();
                const boardWidth = this.pyramidContainer.offsetWidth;
                const boardHeight = this.pyramidContainer.offsetHeight;

                // Calculate cube size based on board size and pyramid size
                const maxCubeSize = Math.min(boardWidth / (this.pyramidSize + 2), boardHeight / (this.pyramidSize + 2));
                const cubeSize = Math.min(32, maxCubeSize);
                const spacing = cubeSize + 4;
                
                // Center the pyramid
                const pyramidWidth = (this.pyramidSize * spacing);
                const pyramidHeight = (this.pyramidSize * spacing);
                const startX = (boardWidth - pyramidWidth) / 2 + (pyramidWidth / 2);
                const startY = (boardHeight - pyramidHeight) / 2 + 40;

                for (let row = 0; row < this.pyramidSize; row++) {
                    this.cubes[row] = [];
                    const cubesInRow = this.pyramidSize - row;
                    
                    for (let col = 0; col < cubesInRow; col++) {
                        const cube = document.createElement('div');
                        cube.className = 'cube';
                        
                        // Position cubes in pyramid formation - centered
                        const x = startX + (col * spacing) - (cubesInRow * spacing / 2) + (spacing / 2);
                        const y = startY + (row * spacing * 0.8); // Slightly compressed vertically
                        
                        cube.style.left = `${x}px`;
                        cube.style.top = `${y}px`;
                        cube.style.width = `${cubeSize}px`;
                        cube.style.height = `${cubeSize}px`;
                        
                        this.pyramidContainer.appendChild(cube);
                        this.cubes[row][col] = {
                            element: cube,
                            changed: false,
                            x: x,
                            y: y,
                            size: cubeSize
                        };
                    }
                }
            }

            createPlayer() {
                if (this.player) {
                    this.player.remove();
                }
                
                this.player = document.createElement('div');
                this.player.className = 'character';
                this.pyramidContainer.appendChild(this.player);
                
                this.playerPos = { row: 0, col: 0 };
                this.updatePlayerPosition();
            }

            updatePlayerPosition() {
                if (this.cubes[this.playerPos.row] && this.cubes[this.playerPos.row][this.playerPos.col]) {
                    const cube = this.cubes[this.playerPos.row][this.playerPos.col];
                    const playerSize = parseInt(getComputedStyle(this.player).width);
                    const offsetX = (cube.size - playerSize) / 2;
                    const offsetY = (cube.size - playerSize) / 2;
                    
                    this.player.style.left = `${cube.x + offsetX}px`;
                    this.player.style.top = `${cube.y + offsetY}px`;
                }
            }

            movePlayer(direction) {
                const oldPos = { ...this.playerPos };
                
                switch(direction) {
                    case 'up':
                        if (this.playerPos.row > 0) {
                            this.playerPos.row--;
                            // Stay in same column or adjust if needed
                            const maxCol = this.pyramidSize - this.playerPos.row - 1;
                            if (this.playerPos.col > maxCol) {
                                this.playerPos.col = maxCol;
                            }
                        } else {
                            this.loseLife();
                            return;
                        }
                        break;
                    case 'down':
                        if (this.playerPos.row < this.pyramidSize - 1) {
                            this.playerPos.row++;
                        } else {
                            this.loseLife();
                            return;
                        }
                        break;
                    case 'left':
                        if (this.playerPos.col > 0) {
                            this.playerPos.col--;
                        } else {
                            this.loseLife();
                            return;
                        }
                        break;
                    case 'right':
                        const maxCol = this.pyramidSize - this.playerPos.row - 1;
                        if (this.playerPos.col < maxCol) {
                            this.playerPos.col++;
                        } else {
                            this.loseLife();
                            return;
                        }
                        break;
                }

                // Check if position is valid
                if (!this.cubes[this.playerPos.row] || !this.cubes[this.playerPos.row][this.playerPos.col]) {
                    this.loseLife();
                    return;
                }

                this.player.classList.add('jumping');
                setTimeout(() => this.player.classList.remove('jumping'), 300);
                
                this.updatePlayerPosition();
                this.changeCube(this.playerPos.row, this.playerPos.col);
                this.checkCollisions();
                this.checkLevelComplete();
            }

            changeCube(row, col) {
                const cube = this.cubes[row][col];
                if (!cube.changed) {
                    cube.element.classList.add('changing');
                    setTimeout(() => cube.element.classList.remove('changing'), 300);
                    
                    cube.changed = true;
                    cube.element.classList.add('active');
                    
                    this.score += 25;
                    this.cubesChanged++;
                    this.updateDisplay();
                    
                    // Chance to spawn power-up
                    if (Math.random() < 0.1) {
                        this.spawnPowerUp(cube.x, cube.y);
                    }
                }
            }

            spawnEnemy() {
                if (!this.gameRunning) return;
                
                const enemy = document.createElement('div');
                enemy.className = 'enemy';
                
                // Random starting position on top row
                const startCol = Math.floor(Math.random() * this.pyramidSize);
                const startCube = this.cubes[0][startCol];
                
                const enemySize = parseInt(getComputedStyle(enemy).width) || 20;
                const offsetX = (startCube.size - enemySize) / 2;
                const offsetY = (startCube.size - enemySize) / 2;
                
                enemy.style.left = `${startCube.x + offsetX}px`;
                enemy.style.top = `${startCube.y + offsetY}px`;
                
                this.pyramidContainer.appendChild(enemy);
                
                const enemyData = {
                    element: enemy,
                    row: 0,
                    col: startCol,
                    moveTimer: null
                };
                
                this.enemies.push(enemyData);
                this.moveEnemyRandomly(enemyData);
            }

            moveEnemyRandomly(enemyData) {
               if (!this.gameRunning) return;
               
               enemyData.moveTimer = setTimeout(() => {
                   const directions = ['down', 'left', 'right'];
                   const direction = directions[Math.floor(Math.random() * directions.length)];
                   
                   let newRow = enemyData.row;
                   let newCol = enemyData.col;
                   
                   switch(direction) {
                       case 'down':
                           if (newRow < this.pyramidSize - 1) newRow++;
                           break;
                       case 'left':
                           if (newCol > 0) newCol--;
                           break;
                       case 'right':
                           const maxCol = this.pyramidSize - newRow - 1;
                           if (newCol < maxCol) newCol++;
                           break;
                   }
                   
                   // Check if new position is valid
                   if (this.cubes[newRow] && this.cubes[newRow][newCol]) {
                       enemyData.row = newRow;
                       enemyData.col = newCol;
                       
                       const cube = this.cubes[newRow][newCol];
                       const enemySize = parseInt(getComputedStyle(enemyData.element).width) || 20;
                       const offsetX = (cube.size - enemySize) / 2;
                       const offsetY = (cube.size - enemySize) / 2;
                       
                       enemyData.element.style.left = `${cube.x + offsetX}px`;
                       enemyData.element.style.top = `${cube.y + offsetY}px`;
                   }
                   
                   this.checkCollisions();
                   this.moveEnemyRandomly(enemyData);
               }, this.enemySpeed + Math.random() * 1000);
           }

           spawnPowerUp(x, y) {
               const powerUp = document.createElement('div');
               powerUp.style.position = 'absolute';
               powerUp.style.left = `${x + 10}px`;
               powerUp.style.top = `${y + 10}px`;
               powerUp.style.width = '12px';
               powerUp.style.height = '12px';
               powerUp.style.borderRadius = '50%';
               powerUp.style.background = '#00ff88';
               powerUp.style.boxShadow = '0 0 10px #00ff88';
               powerUp.style.zIndex = '5';
               
               this.pyramidContainer.appendChild(powerUp);
               
               const powerUpData = {
                   element: powerUp,
                   x: x + 10,
                   y: y + 10,
                   type: 'freeze'
               };
               
               this.powerUps.push(powerUpData);
               
               // Remove power-up after 10 seconds
               setTimeout(() => {
                   this.removePowerUp(powerUpData);
               }, 10000);
           }

           removePowerUp(powerUpData) {
               const index = this.powerUps.indexOf(powerUpData);
               if (index > -1) {
                   this.powerUps.splice(index, 1);
                   if (powerUpData.element.parentNode) {
                       powerUpData.element.remove();
                   }
               }
           }

           checkCollisions() {
               // Check enemy collisions
               this.enemies.forEach(enemy => {
                   if (enemy.row === this.playerPos.row && enemy.col === this.playerPos.col) {
                       this.loseLife();
                   }
               });
               
               // Check power-up collisions
               this.powerUps.forEach(powerUp => {
                   const playerCube = this.cubes[this.playerPos.row][this.playerPos.col];
                   const distance = Math.sqrt(
                       Math.pow(powerUp.x - (playerCube.x + playerCube.size/2), 2) +
                       Math.pow(powerUp.y - (playerCube.y + playerCube.size/2), 2)
                   );
                   
                   if (distance < 20) {
                       this.collectPowerUp(powerUp);
                   }
               });
           }

           collectPowerUp(powerUpData) {
               this.score += 100;
               this.updateDisplay();
               
               // Freeze enemies for 3 seconds
               this.enemies.forEach(enemy => {
                   if (enemy.moveTimer) {
                       clearTimeout(enemy.moveTimer);
                       enemy.element.style.opacity = '0.5';
                       
                       setTimeout(() => {
                           enemy.element.style.opacity = '1';
                           this.moveEnemyRandomly(enemy);
                       }, 3000);
                   }
               });
               
               this.removePowerUp(powerUpData);
           }

           checkLevelComplete() {
               let allChanged = true;
               for (let row = 0; row < this.pyramidSize; row++) {
                   for (let col = 0; col < this.cubes[row].length; col++) {
                       if (!this.cubes[row][col].changed) {
                           allChanged = false;
                           break;
                       }
                   }
                   if (!allChanged) break;
               }
               
               if (allChanged) {
                   this.completeLevel();
               }
           }

           completeLevel() {
               this.level++;
               this.score += 500 * this.level;
               this.pyramidSize = Math.min(6, 4 + Math.floor(this.level / 2)); // Gradually increase pyramid size
               this.enemySpeed = Math.max(800, this.enemySpeed - 200);
               
               // Clear enemies
               this.enemies.forEach(enemy => {
                   if (enemy.moveTimer) clearTimeout(enemy.moveTimer);
                   enemy.element.remove();
               });
               this.enemies = [];
               
               // Clear power-ups
               this.powerUps.forEach(powerUp => powerUp.element.remove());
               this.powerUps = [];
               
               this.createPyramid();
               this.createPlayer();
               this.updateDisplay();
               
               // Show level complete message
               this.showMessage('Level Complete!', 2000);
               
               // Start spawning enemies for new level
               setTimeout(() => {
                   this.startEnemySpawning();
               }, 2000);
           }

           loseLife() {
               this.lives--;
               this.updateDisplay();
               
               if (this.lives <= 0) {
                   this.gameOver();
               } else {
                   // Reset player position
                   this.playerPos = { row: 0, col: 0 };
                   this.updatePlayerPosition();
                   this.showMessage('Life Lost!', 1500);
               }
           }

           startGame() {
               this.gameRunning = true;
               this.gameStarted = true;
               
               document.getElementById('startBtn').style.display = 'none';
               document.getElementById('newGameBtn').style.display = 'inline-block';
               
               this.startEnemySpawning();
               this.startPowerUpSpawning();
           }

           startEnemySpawning() {
               if (!this.gameRunning) return;
               
               // Spawn first enemy after 3 seconds
               setTimeout(() => {
                   this.spawnEnemy();
                   
                   // Then spawn enemies periodically
                   this.enemySpawnTimer = setInterval(() => {
                       if (this.gameRunning && this.enemies.length < 3) {
                           this.spawnEnemy();
                       }
                   }, Math.max(3000, 8000 - (this.level * 500)));
               }, 3000);
           }

           startPowerUpSpawning() {
               if (!this.gameRunning) return;
               
               this.powerUpSpawnTimer = setInterval(() => {
                   if (this.gameRunning && this.powerUps.length < 2) {
                       // Random position on pyramid
                       const row = Math.floor(Math.random() * this.pyramidSize);
                       const col = Math.floor(Math.random() * (this.pyramidSize - row));
                       const cube = this.cubes[row][col];
                       this.spawnPowerUp(cube.x, cube.y);
                   }
               }, this.powerUpSpawnRate);
           }

           resetGame() {
               this.gameRunning = false;
               this.gameStarted = false;
               
               // Clear timers
               if (this.enemySpawnTimer) clearInterval(this.enemySpawnTimer);
               if (this.powerUpSpawnTimer) clearInterval(this.powerUpSpawnTimer);
               
               // Clear enemies
               this.enemies.forEach(enemy => {
                   if (enemy.moveTimer) clearTimeout(enemy.moveTimer);
                   enemy.element.remove();
               });
               this.enemies = [];
               
               // Clear power-ups
               this.powerUps.forEach(powerUp => powerUp.element.remove());
               this.powerUps = [];
               
               // Reset game state
               this.score = 0;
               this.level = 1;
               this.lives = 3;
               this.cubesChanged = 0;
               this.pyramidSize = 6;
               this.enemySpeed = 2000;
               
               // Reset UI
               document.getElementById('startBtn').style.display = 'inline-block';
               document.getElementById('newGameBtn').style.display = 'none';
               this.hideGameOver();
               
               // Recreate game elements
               this.initializeGame();
           }

           gameOver() {
               this.gameRunning = false;
               
               // Clear timers
               if (this.enemySpawnTimer) clearInterval(this.enemySpawnTimer);
               if (this.powerUpSpawnTimer) clearInterval(this.powerUpSpawnTimer);
               
               // Stop enemy movement
               this.enemies.forEach(enemy => {
                   if (enemy.moveTimer) clearTimeout(enemy.moveTimer);
               });
               
               this.saveBestScore();
               this.showGameOver();
           }

           showGameOver() {
               const modal = document.getElementById('gameOverModal');
               const title = document.getElementById('gameOverTitle');
               
               if (this.level > 3) {
                   title.textContent = 'Great Job!';
                   title.style.background = 'var(--success-color)';
               } else {
                   title.textContent = 'Game Over!';
                   title.style.background = 'var(--secondary-gradient)';
               }
               
               document.getElementById('finalScore').textContent = this.score.toLocaleString();
               document.getElementById('finalLevel').textContent = this.level;
               document.getElementById('bestScore').textContent = this.getBestScore().toLocaleString();
               document.getElementById('cubesChanged').textContent = this.cubesChanged;
               
               modal.style.display = 'flex';
           }

           hideGameOver() {
               document.getElementById('gameOverModal').style.display = 'none';
           }

           showMessage(text, duration = 2000) {
               const message = document.createElement('div');
               message.style.position = 'fixed';
               message.style.top = '50%';
               message.style.left = '50%';
               message.style.transform = 'translate(-50%, -50%)';
               message.style.background = 'var(--card-bg)';
               message.style.color = 'var(--text-primary)';
               message.style.padding = '1rem 2rem';
               message.style.borderRadius = '10px';
               message.style.border = '2px solid var(--accent-color)';
               message.style.fontSize = '1.2rem';
               message.style.fontWeight = '600';
               message.style.zIndex = '999';
               message.style.backdropFilter = 'blur(20px)';
               message.textContent = text;
               
               document.body.appendChild(message);
               
               setTimeout(() => {
                   if (message.parentNode) {
                       message.remove();
                   }
               }, duration);
           }

           updateDisplay() {
               this.scoreElement.textContent = this.score.toLocaleString();
               this.levelElement.textContent = this.level;
               this.livesElement.textContent = this.lives;
           }

           saveBestScore() {
               const bestScore = this.getBestScore();
               if (this.score > bestScore) {
                   localStorage.setItem('qbert-quest-best-score', this.score.toString());
               }
           }

           getBestScore() {
               return parseInt(localStorage.getItem('qbert-quest-best-score') || '0');
           }

           loadBestScore() {
               // Initialize best score display if needed
               const bestScore = this.getBestScore();
               if (bestScore > 0) {
                   console.log('Best Score:', bestScore);
               }
           }
       }

       // Initialize game when page loads
       let game;
       document.addEventListener('DOMContentLoaded', () => {
           game = new QbertGame();
       });

       // Prevent context menu on game area
       document.getElementById('gameBoard').addEventListener('contextmenu', (e) => {
           e.preventDefault();
       });

       // Handle visibility change to pause game
       document.addEventListener('visibilitychange', () => {
           if (document.hidden && game && game.gameRunning) {
               // Could implement pause functionality here
           }
       });
   </script>
</body>
</html>