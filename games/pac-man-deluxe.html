<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man Deluxe - Free HTML5 Game | GameHub 99</title>
    <meta name="description" content="Play Pac-Man Deluxe for free! Classic arcade action with modern twists, power-ups, and ghosts. Mobile-friendly browser game with no download required.">
    <meta name="keywords" content="pac-man, pacman deluxe, arcade game, html5 game, free online game, browser game, mobile game, ghosts, maze">
    <meta name="author" content="GameHub 99">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="game">
    <meta property="og:url" content="https://gamehub99.com/games/pac-man-deluxe.html">
    <meta property="og:title" content="Pac-Man Deluxe - Free HTML5 Game">
    <meta property="og:description" content="Classic arcade action with modern twists and power-ups!">
    <meta property="og:image" content="https://gamehub99.com/assets/pac-man-deluxe-og.jpg">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://gamehub99.com/games/pac-man-deluxe.html">
    <meta property="twitter:title" content="Pac-Man Deluxe - Free HTML5 Game">
    <meta property="twitter:description" content="Classic arcade action with modern twists and power-ups!">
    <meta property="twitter:image" content="https://gamehub99.com/assets/pac-man-deluxe-og.jpg">

    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-gradient: linear-gradient(135deg, #ffff00 0%, #ffaa00 100%);
            --secondary-gradient: linear-gradient(135deg, #ff6b6b 0%, #feca57 100%);
            --dark-gradient: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 100%);
            --accent-color: #00d4ff;
            --success-color: #00ff88;
            --warning-color: #ffaa00;
            --text-primary: #ffffff;
            --text-secondary: #b8c1ec;
            --card-bg: rgba(255, 255, 255, 0.05);
            --card-border: rgba(255, 255, 255, 0.1);
            --shadow-glow: 0 0 40px rgba(255, 255, 0, 0.3);
            --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: "Inter", sans-serif;
            background: var(--dark-gradient);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .ad-container-top, .ad-container-bottom {
            width: 100%;
            min-height: 90px;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid var(--card-border);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .ad-placeholder {
            width: 728px;
            height: 90px;
            background: linear-gradient(45deg, #333, #555);
            border: 2px dashed #666;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 14px;
            border-radius: 8px;
        }

        .header {
            padding: 1rem 0;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--card-border);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .game-title {
            font-family: "Orbitron", monospace;
            font-size: 2rem;
            font-weight: 900;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            flex-shrink: 0;
        }

        .nav-buttons {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .nav-button {
            padding: 10px 20px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 25px;
            color: var(--text-primary);
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .nav-button:hover {
            background: var(--accent-color);
            color: #000;
            transform: translateY(-2px);
        }

        .game-container {
            flex: 1;
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            gap: 2rem;
            width: 100%;
        }

        .game-section {
            flex: 2;
            min-width: 320px;
        }

        .game-header {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            margin-bottom: 1.5rem;
            gap: 1rem;
        }

        .stats-section {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            min-width: 340px;
        }

        .stat-box {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 10px;
            padding: 0.8rem 1rem;
            text-align: center;
            backdrop-filter: blur(10px);
            min-width: 80px;
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.3rem;
        }

        .stat-value {
            font-family: "Orbitron", monospace;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent-color);
        }

        .game-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.8rem;
            min-width: 300px;
        }

        .control-button {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
            white-space: nowrap;
            text-align: center;
            min-height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-card);
        }

        .control-button:nth-child(1) {
            background: var(--success-color);
            grid-column: 1;
        }

        .control-button:nth-child(2) {
            background: var(--warning-color);
            grid-column: 2;
        }

        .control-button:nth-child(3) {
            background: var(--accent-color);
            color: #000;
            grid-column: 3;
        }

        .game-canvas-container {
            background: var(--card-bg);
            border: 2px solid var(--card-border);
            border-radius: 15px;
            padding: 1rem;
            backdrop-filter: blur(10px);
            position: relative;
            text-align: center;
        }

        #gameCanvas {
            background: #000;
            border: 2px solid #0066ff;
            border-radius: 10px;
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
        }

        .start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .start-overlay:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        .start-overlay h2 {
            font-family: "Orbitron", monospace;
            font-size: 2rem;
            margin-bottom: 1rem;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .start-overlay p {
            color: var(--text-secondary);
            margin-bottom: 2rem;
        }

        .start-button {
            padding: 15px 30px;
            background: var(--primary-gradient);
            border: none;
            border-radius: 25px;
            color: #000;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
        }

        .mobile-controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-top: 1.5rem;
            max-width: 250px;
            margin-left: auto;
            margin-right: auto;
        }

        .mobile-control {
            aspect-ratio: 1;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            user-select: none;
        }

        .mobile-control:active {
            transform: scale(0.95);
            background: var(--accent-color);
        }

        .sidebar {
            flex: 1;
            min-width: 300px;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .info-section {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 15px;
            padding: 1.5rem;
            backdrop-filter: blur(10px);
        }

        .info-section h3 {
            font-family: "Orbitron", monospace;
            font-size: 1.2rem;
            margin-bottom: 1rem;
            color: var(--accent-color);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .modal-content {
            background: var(--dark-gradient);
            border: 2px solid var(--card-border);
            border-radius: 20px;
            padding: 2rem;
            max-width: 400px;
            width: 90%;
            text-align: center;
            position: relative;
            animation: modalSlideIn 0.3s ease;
        }

        .modal-button {
            padding: 12px 24px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 10px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            margin: 0.5rem;
        }

        .modal-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-card);
        }

        .modal-button.primary {
            background: var(--accent-color);
            color: #000;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes modalSlideIn {
            from { transform: scale(0.8) translateY(-50px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                padding: 1rem;
            }
            
            .mobile-controls {
                display: grid;
            }
            
            .header-content {
                padding: 0 1rem;
            }
            
            .game-title {
                font-size: 1.5rem;
            }
            
            .ad-placeholder {
                width: 320px;
                height: 50px;
                font-size: 12px;
            }
            
            .game-header {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .stats-section {
                grid-template-columns: repeat(2, 1fr);
                justify-self: center;
            }
            
            .game-controls {
                justify-self: center;
            }
        }
    </style>
</head>
<body>
    <!-- Top Ad Container -->
    <div class="ad-container-top">
        <div class="ad-placeholder">728x90 Header Advertisement</div>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <h1 class="game-title">🌟 Pac-Man Deluxe</h1>
            <nav class="nav-buttons">
                <a href="/" class="nav-button">🏠 Home</a>
                <a href="/games" class="nav-button">🎮 More Games</a>
                <a href="#" class="nav-button" onclick="showInstructions()">❓ How to Play</a>
                <a href="#" class="nav-button" onclick="toggleFullscreen()">📱 Fullscreen</a>
            </nav>
        </div>
    </header>

    <!-- Main Game Container -->
    <div class="game-container">
        <!-- Game Section -->
        <main class="game-section">
            <div class="game-header">
                <div class="stats-section">
                    <div class="stat-box">
                        <div class="stat-label">Score</div>
                        <div class="stat-value" id="currentScore">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Best</div>
                        <div class="stat-value" id="bestScore">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Level</div>
                        <div class="stat-value" id="gameLevel">1</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Lives</div>
                        <div class="stat-value" id="gameLives">3</div>
                    </div>
                </div>
                
                <div class="game-controls">
                    <button class="control-button" onclick="newGame()">🆕 New Game</button>
                    <button class="control-button" onclick="togglePause()" id="pauseButton">⏸️ Pause</button>
                    <button class="control-button" onclick="showLeaderboard()">🏆 Scores</button>
                </div>
            </div>

            <!-- Game Canvas -->
            <div class="game-canvas-container">
                <canvas id="gameCanvas" width="400" height="400"></canvas>
                <div class="start-overlay" id="startOverlay">
                    <h2>🌟 Pac-Man Deluxe</h2>
                    <p>Collect all dots while avoiding ghosts!</p>
                    <button class="start-button" onclick="startGame()">🎮 Start Game</button>
                </div>
            </div>

            <!-- Mobile Controls -->
            <div class="mobile-controls">
                <div class="mobile-control"></div>
                <div class="mobile-control" onclick="setPlayerDirection(0, -1)">⬆️</div>
                <div class="mobile-control"></div>
                <div class="mobile-control" onclick="setPlayerDirection(-1, 0)">⬅️</div>
                <div class="mobile-control" onclick="togglePause()">⏸️</div>
                <div class="mobile-control" onclick="setPlayerDirection(1, 0)">➡️</div>
                <div class="mobile-control"></div>
                <div class="mobile-control" onclick="setPlayerDirection(0, 1)">⬇️</div>
                <div class="mobile-control"></div>
            </div>
        </main>

        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="info-section">
                <h3>🎯 How to Play</h3>
                <p><strong>Objective:</strong> Collect all dots while avoiding the colorful ghosts!</p>
                <ul style="text-align: left; margin-top: 1rem; line-height: 1.8;">
                    <li>Use arrow keys or WASD to move</li>
                    <li>Collect dots for points</li>
                    <li>Eat power pellets to turn ghosts blue</li>
                    <li>Avoid ghosts or lose a life</li>
                    <li>Clear all dots to advance levels</li>
                    <li>Use tunnels on left/right to escape!</li>
                </ul>
            </div>

            <div class="info-section">
                <h3>🏆 Power-ups</h3>
                <ul style="text-align: left; line-height: 1.8;">
                    <li>🔴 <strong>Power Pellet:</strong> Makes ghosts vulnerable</li>
                    <li>🍒 <strong>Cherry:</strong> Bonus points</li>
                    <li>⚡ <strong>Speed Boost:</strong> Move faster</li>
                    <li>💎 <strong>Super Dot:</strong> Extra points</li>
                </ul>
            </div>

            <div class="info-section">
                <h3>📊 Game Stats</h3>
                <p><strong>Games Played:</strong> <span id="gamesPlayed">0</span></p>
                <p><strong>Total Score:</strong> <span id="totalScore">0</span></p>
                <p><strong>Best Streak:</strong> <span id="bestStreak">0</span></p>
            </div>
        </aside>
    </div>

    <!-- Game Over Modal -->
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 style="color: var(--warning-color); margin-bottom: 1rem;">Game Over!</h2>
            <p style="margin-bottom: 1rem;">Your Score: <span id="finalScore" style="color: var(--accent-color); font-weight: bold;">0</span></p>
            <p style="margin-bottom: 2rem;">Level Reached: <span id="finalLevel" style="color: var(--success-color); font-weight: bold;">1</span></p>
            <div>
                <button class="modal-button primary" onclick="newGame()">🎮 Play Again</button>
                <button class="modal-button" onclick="shareScore()">📤 Share Score</button>
                <button class="modal-button" onclick="closeModal()">❌ Close</button>
            </div>
        </div>
    </div>

    <!-- Bottom Ad Container -->
    <div class="ad-container-bottom">
        <div class="ad-placeholder">728x90 Footer Advertisement</div>
    </div>

    <script>
        // Game Variables
        let canvas, ctx;
        let game = {
            score: 0,
            level: 1,
            lives: 3,
            gameRunning: false,
            gamePaused: false,
            gameStarted: false
        };

        // Game grid
        const GRID_SIZE = 20;
        const ROWS = 20;
        const COLS = 20;

        // Game timing
        let lastTime = 0;
        let ghostMoveCounter = 0;
        let playerMoveCounter = 0;
        const GHOST_MOVE_SPEED = 15; // Ghosts move every 15 frames
        const PLAYER_MOVE_SPEED = 8; // Player moves every 8 frames

        // Game objects
        let player = { x: 1, y: 1, dx: 0, dy: 0, nextDx: 0, nextDy: 0 };
        let ghosts = [];
        let dots = [];
        let powerPellets = [];
        let maze = [];

        // Initialize maze layout - improved for better accessibility
        function initMaze() {
            maze = [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,0,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1],
                [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
                [1,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,1],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // Horizontal tunnel
                [1,1,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1],
                [0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0], // Center open area
                [1,1,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1],
                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], // Horizontal tunnel
                [1,1,1,0,1,1,1,1,0,1,1,0,1,1,1,1,0,1,1,1],
                [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
                [1,0,1,0,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,0,1],
                [1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ];
            console.log("Maze initialized with dimensions:", maze.length, "x", maze[0] ? maze[0].length : 0);
        }

        // Initialize game
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // Initialize maze first
            initMaze();
            
            loadGameStats();
            setupEventListeners();
            
            console.log("Pac-Man Deluxe initialized!");
        }

        // Setup event listeners
        function setupEventListeners() {
            document.addEventListener('keydown', handleKeyPress);
            
            // Touch events for mobile
            let touchStartX, touchStartY;
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (!touchStartX || !touchStartY) return;

                const touch = e.changedTouches[0];
                const touchEndX = touch.clientX;
                const touchEndY = touch.clientY;

                const diffX = touchStartX - touchEndX;
                const diffY = touchStartY - touchEndY;

                if (Math.abs(diffX) > Math.abs(diffY)) {
                    if (diffX > 0) setPlayerDirection(-1, 0); // Left
                    else setPlayerDirection(1, 0); // Right
                } else {
                    if (diffY > 0) setPlayerDirection(0, -1); // Up
                    else setPlayerDirection(0, 1); // Down
                }

                touchStartX = null;
                touchStartY = null;
            });
        }

        // Handle keyboard input - set direction
        function handleKeyPress(e) {
            if (!game.gameRunning) return;

            switch(e.key.toLowerCase()) {
                case 'arrowup':
                case 'w':
                    e.preventDefault();
                    setPlayerDirection(0, -1);
                    break;
                case 'arrowdown':
                case 's':
                    e.preventDefault();
                    setPlayerDirection(0, 1);
                    break;
                case 'arrowleft':
                case 'a':
                    e.preventDefault();
                    setPlayerDirection(-1, 0);
                    break;
                case 'arrowright':
                case 'd':
                    e.preventDefault();
                    setPlayerDirection(1, 0);
                    break;
                case ' ':
                    e.preventDefault();
                    togglePause();
                    break;
                case 'n':
                    e.preventDefault();
                    newGame();
                    break;
            }
        }

        // Set player direction for continuous movement
        function setPlayerDirection(dx, dy) {
            if (!game.gameRunning || game.gamePaused) return;
            player.nextDx = dx;
            player.nextDy = dy;
        }

        // Start game
        function startGame() {
            document.getElementById('startOverlay').style.display = 'none';
            game.gameStarted = true;
            game.gameRunning = true;
            game.gamePaused = false;
            resetGameState();
            createDots();
            createGhosts();
            gameLoop();
            trackEvent('game_started');
        }

        // Reset game state
        function resetGameState() {
            player = { x: 1, y: 1, dx: 0, dy: 0, nextDx: 0, nextDy: 0 };
            ghosts = [];
            dots = [];
            powerPellets = [];
            game.score = 0;
            game.level = 1;
            game.lives = 3;
            ghostMoveCounter = 0;
            playerMoveCounter = 0;
            updateUI();
        }

        // Create dots on the maze - all accessible paths
        function createDots() {
            dots = [];
            powerPellets = [];
            
            console.log("Creating dots... maze dimensions:", maze.length, "x", (maze[0] ? maze[0].length : 0));
            
            if (!maze || maze.length === 0) {
                console.error("Maze not initialized!");
                initMaze(); // Re-initialize if needed
            }
            
            for (let row = 0; row < ROWS && row < maze.length; row++) {
                if (!maze[row]) {
                    console.error("Maze row", row, "is undefined");
                    continue;
                }
                
                for (let col = 0; col < COLS && col < maze[row].length; col++) {
                    if (maze[row][col] === 0) {
                        // Skip player starting position and central ghost area
                        if ((row === 1 && col === 1) || 
                           (row >= 8 && row <= 11 && col >= 8 && col <= 11)) continue;
                       
                       // Add dots to all accessible spaces
                       dots.push({ x: col, y: row, type: 'dot', points: 10 });
                   }
               }
           }
           
           // Add power pellets in 4 corners and remove regular dots there
           const powerPelletPositions = [
               {x: 1, y: 3}, {x: 18, y: 3}, {x: 1, y: 15}, {x: 18, y: 15}
           ];
           
           powerPelletPositions.forEach(pos => {
               // Remove any regular dot at this position
               for (let i = dots.length - 1; i >= 0; i--) {
                   if (dots[i].x === pos.x && dots[i].y === pos.y) {
                       dots.splice(i, 1);
                       break;
                   }
               }
               // Add power pellet
               powerPellets.push({ x: pos.x, y: pos.y, active: true });
           });
           
           console.log("Created", dots.length, "dots and", powerPellets.length, "power pellets");
       }

       // Create ghosts
       function createGhosts() {
           ghosts = [
               { x: 9, y: 9, dx: 1, dy: 0, color: '#ff0000', vulnerable: false, vulnerableTime: 0 },
               { x: 10, y: 9, dx: -1, dy: 0, color: '#ffb6c1', vulnerable: false, vulnerableTime: 0 },
               { x: 9, y: 10, dx: 0, dy: 1, color: '#00ffff', vulnerable: false, vulnerableTime: 0 },
               { x: 10, y: 10, dx: 0, dy: -1, color: '#ffa500', vulnerable: false, vulnerableTime: 0 }
           ];
       }

       // Move player continuously
       function movePlayer() {
           playerMoveCounter++;
           if (playerMoveCounter < PLAYER_MOVE_SPEED) {
               return;
           }
           playerMoveCounter = 0;

           // Try to change direction if new direction is requested
           if (player.nextDx !== 0 || player.nextDy !== 0) {
               const newX = player.x + player.nextDx;
               const newY = player.y + player.nextDy;
               
               // Handle tunnel wrapping for direction change
               let canChangeDirection = false;
               if (player.nextDx < 0 && player.x === 0) {
                   // Left tunnel
                   if (player.y === 7 || player.y === 9 || player.y === 11) {
                       canChangeDirection = true;
                   }
               } else if (player.nextDx > 0 && player.x === COLS - 1) {
                   // Right tunnel
                   if (player.y === 7 || player.y === 9 || player.y === 11) {
                       canChangeDirection = true;
                   }
               } else if (newX >= 0 && newX < COLS && newY >= 0 && newY < ROWS && 
                         maze[newY] && maze[newY][newX] === 0) {
                   canChangeDirection = true;
               }
               
               if (canChangeDirection) {
                   player.dx = player.nextDx;
                   player.dy = player.nextDy;
                   player.nextDx = 0;
                   player.nextDy = 0;
               }
           }

           // Continue moving in current direction
           if (player.dx !== 0 || player.dy !== 0) {
               let newX = player.x + player.dx;
               let newY = player.y + player.dy;

               // Handle left-right tunnel wrapping
               if (newX < 0) {
                   if (newY === 7 || newY === 9 || newY === 11) {
                       newX = COLS - 1; // Wrap to right side
                   } else {
                       player.dx = 0; // Stop if not in tunnel
                       player.dy = 0;
                       return;
                   }
               } else if (newX >= COLS) {
                   if (newY === 7 || newY === 9 || newY === 11) {
                       newX = 0; // Wrap to left side
                   } else {
                       player.dx = 0; // Stop if not in tunnel
                       player.dy = 0;
                       return;
                   }
               }

               // Check bounds and walls for normal movement
               if (newY >= 0 && newY < ROWS && 
                   maze[newY] && maze[newY][newX] === 0) {
                   player.x = newX;
                   player.y = newY;
                   checkCollisions();
               } else {
                   // Stop if hitting wall
                   player.dx = 0;
                   player.dy = 0;
               }
           }
       }

       // Handle ghost tunnel wrapping
       function wrapGhost(ghost) {
           // Handle left-right tunnel wrapping for ghosts
           if (ghost.x < 0) {
               if (ghost.y === 7 || ghost.y === 9 || ghost.y === 11) {
                   ghost.x = COLS - 1;
               }
           } else if (ghost.x >= COLS) {
               if (ghost.y === 7 || ghost.y === 9 || ghost.y === 11) {
                   ghost.x = 0;
               }
           }
       }

       // Check collisions
       function checkCollisions() {
           // Check dot collision
           for (let i = dots.length - 1; i >= 0; i--) {
               if (dots[i].x === player.x && dots[i].y === player.y) {
                   game.score += dots[i].points;
                   dots.splice(i, 1);
                   updateUI();
                   
                   // Check if all dots collected
                   if (dots.length === 0) {
                       nextLevel();
                       return;
                   }
               }
           }

           // Check power pellet collision
           for (let i = powerPellets.length - 1; i >= 0; i--) {
               if (powerPellets[i].x === player.x && powerPellets[i].y === player.y && powerPellets[i].active) {
                   game.score += 50;
                   powerPellets[i].active = false;
                   
                   // Make all ghosts vulnerable
                   ghosts.forEach(ghost => {
                       ghost.vulnerable = true;
                       ghost.vulnerableTime = 300; // 5 seconds at 60fps
                   });
                   updateUI();
               }
           }

           // Check ghost collision - FIXED LOGIC
           ghosts.forEach((ghost, index) => {
               if (ghost.x === player.x && ghost.y === player.y) {
                   if (ghost.vulnerable) {
                       // Eat ghost - award points and respawn ghost
                       game.score += 200;
                       ghost.vulnerable = false;
                       ghost.vulnerableTime = 0;
                       // Respawn ghost at center
                       ghost.x = 9 + Math.floor(Math.random() * 2);
                       ghost.y = 9 + Math.floor(Math.random() * 2);
                       updateUI();
                   } else {
                       // Player hit non-vulnerable ghost - lose life
                       loseLife();
                       return; // Exit to prevent multiple life losses
                   }
               }
           });
       }

       // Lose a life - FIXED to prevent pause popup
       function loseLife() {
           game.lives--;
           updateUI();
           
           if (game.lives <= 0) {
               gameOver();
           } else {
               // Reset player position and stop movement
               player.x = 1;
               player.y = 1;
               player.dx = 0;
               player.dy = 0;
               player.nextDx = 0;
               player.nextDy = 0;
               
               // Reset ghosts to starting positions
               createGhosts();
               
               // Brief visual indication without pause
               console.log("Life lost! Lives remaining:", game.lives);
           }
       }

       // Next level
       function nextLevel() {
           game.level++;
           updateUI();
           
           // Brief pause for level transition
           game.gamePaused = true;
           
           setTimeout(() => {
               createDots();
               createGhosts();
               // Reset player position and stop movement
               player.x = 1;
               player.y = 1;
               player.dx = 0;
               player.dy = 0;
               player.nextDx = 0;
               player.nextDy = 0;
               
               if (game.gameRunning) {
                   game.gamePaused = false;
               }
           }, 1500);
       }

       // Move ghosts (controlled timing with tunnel support)
       function moveGhosts() {
           // Only move ghosts every GHOST_MOVE_SPEED frames
           ghostMoveCounter++;
           if (ghostMoveCounter < GHOST_MOVE_SPEED) {
               return;
           }
           ghostMoveCounter = 0;

           ghosts.forEach(ghost => {
               // Update vulnerable time
               if (ghost.vulnerable && ghost.vulnerableTime > 0) {
                   ghost.vulnerableTime--;
                   if (ghost.vulnerableTime <= 0) {
                       ghost.vulnerable = false;
                   }
               }

               // Simple AI: move randomly when hitting walls
               let newX = ghost.x + ghost.dx;
               let newY = ghost.y + ghost.dy;

               // Handle tunnel wrapping first
               if (newX < 0 || newX >= COLS) {
                   if (newY === 7 || newY === 9 || newY === 11) {
                       ghost.x = newX < 0 ? COLS - 1 : 0;
                       ghost.y = newY;
                       return;
                   }
               }

               // Check if new position is valid
               if (newX < 0 || newX >= COLS || newY < 0 || newY >= ROWS || 
                   !maze[newY] || maze[newY][newX] === 1) {
                   // Change direction randomly
                   const directions = [
                       { dx: 1, dy: 0 },
                       { dx: -1, dy: 0 },
                       { dx: 0, dy: 1 },
                       { dx: 0, dy: -1 }
                   ];
                   const validDirections = directions.filter(dir => {
                       const testX = ghost.x + dir.dx;
                       const testY = ghost.y + dir.dy;
                       
                       // Allow tunnel movement
                       if (testX < 0 || testX >= COLS) {
                           return (testY === 7 || testY === 9 || testY === 11);
                       }
                       
                       return testX >= 0 && testX < COLS && testY >= 0 && testY < ROWS && 
                              maze[testY] && maze[testY][testX] === 0;
                   });
                   
                   if (validDirections.length > 0) {
                       const randomDir = validDirections[Math.floor(Math.random() * validDirections.length)];
                       ghost.dx = randomDir.dx;
                       ghost.dy = randomDir.dy;
                   }
               } else {
                   ghost.x = newX;
                   ghost.y = newY;
               }
               
               // Apply tunnel wrapping after movement
               wrapGhost(ghost);
           });
       }

       // Draw game
       function draw() {
           // Clear canvas
           ctx.fillStyle = '#000';
           ctx.fillRect(0, 0, canvas.width, canvas.height);

           // Draw maze
           ctx.fillStyle = '#0066ff';
           for (let row = 0; row < ROWS && row < maze.length; row++) {
               if (!maze[row]) continue;
               for (let col = 0; col < COLS && col < maze[row].length; col++) {
                   if (maze[row][col] === 1) {
                       ctx.fillRect(col * GRID_SIZE, row * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                   }
               }
           }

           // Draw tunnel indicators
           ctx.fillStyle = '#444';
           // Left tunnel entrances
           ctx.fillRect(-1, 7 * GRID_SIZE, GRID_SIZE, GRID_SIZE);
           ctx.fillRect(-1, 9 * GRID_SIZE, GRID_SIZE, GRID_SIZE);
           ctx.fillRect(-1, 11 * GRID_SIZE, GRID_SIZE, GRID_SIZE);
           // Right tunnel entrances
           ctx.fillRect(COLS * GRID_SIZE, 7 * GRID_SIZE, GRID_SIZE, GRID_SIZE);
           ctx.fillRect(COLS * GRID_SIZE, 9 * GRID_SIZE, GRID_SIZE, GRID_SIZE);
           ctx.fillRect(COLS * GRID_SIZE, 11 * GRID_SIZE, GRID_SIZE, GRID_SIZE);

           // Draw dots
           ctx.fillStyle = '#ffff00';
           dots.forEach(dot => {
               ctx.beginPath();
               ctx.arc(
                   dot.x * GRID_SIZE + GRID_SIZE/2,
                   dot.y * GRID_SIZE + GRID_SIZE/2,
                   2,
                   0,
                   Math.PI * 2
               );
               ctx.fill();
           });

           // Draw power pellets (with blinking effect)
           const blinkTime = Math.floor(Date.now() / 300) % 2;
           if (blinkTime === 0) {
               ctx.fillStyle = '#ffff00';
               powerPellets.forEach(pellet => {
                   if (pellet.active) {
                       ctx.beginPath();
                       ctx.arc(
                           pellet.x * GRID_SIZE + GRID_SIZE/2,
                           pellet.y * GRID_SIZE + GRID_SIZE/2,
                           6,
                           0,
                           Math.PI * 2
                       );
                       ctx.fill();
                   }
               });
           }

           // Draw player (Pac-Man) with animated mouth
           ctx.fillStyle = '#ffff00';
           ctx.beginPath();
           
           // Calculate mouth angle based on direction and add mouth animation
           let startAngle = 0;
           let endAngle = Math.PI * 2;
           const mouthAnimation = Math.sin(Date.now() * 0.01) * 0.3 + 0.5; // Animate mouth opening
           
           if (player.dx === 1) { // Right
               startAngle = 0.2 * Math.PI * mouthAnimation;
               endAngle = (2 - 0.2 * mouthAnimation) * Math.PI;
           } else if (player.dx === -1) { // Left
               startAngle = (1 + 0.2 * mouthAnimation) * Math.PI;
               endAngle = (1 - 0.2 * mouthAnimation) * Math.PI;
           } else if (player.dy === -1) { // Up
               startAngle = (1.5 + 0.2 * mouthAnimation) * Math.PI;
               endAngle = (1.5 - 0.2 * mouthAnimation) * Math.PI;
           } else if (player.dy === 1) { // Down
               startAngle = (0.5 + 0.2 * mouthAnimation) * Math.PI;
               endAngle = (0.5 - 0.2 * mouthAnimation) * Math.PI;
           }
           
           ctx.arc(
               player.x * GRID_SIZE + GRID_SIZE/2,
               player.y * GRID_SIZE + GRID_SIZE/2,
               GRID_SIZE/2 - 2,
               startAngle,
               endAngle
           );
           ctx.lineTo(
               player.x * GRID_SIZE + GRID_SIZE/2,
               player.y * GRID_SIZE + GRID_SIZE/2
           );
           ctx.fill();

           // Draw ghosts
           ghosts.forEach(ghost => {
               ctx.fillStyle = ghost.vulnerable ? '#0000ff' : ghost.color;
               
               // Ghost body
               ctx.beginPath();
               ctx.arc(
                   ghost.x * GRID_SIZE + GRID_SIZE/2,
                   ghost.y * GRID_SIZE + GRID_SIZE/2 - 2,
                   GRID_SIZE/2 - 2,
                   Math.PI,
                   0,
                   false
               );
               ctx.lineTo(ghost.x * GRID_SIZE + GRID_SIZE - 2, ghost.y * GRID_SIZE + GRID_SIZE - 2);
               
               // Ghost bottom with triangular teeth
               for (let i = 0; i < 3; i++) {
                   ctx.lineTo(
                       ghost.x * GRID_SIZE + GRID_SIZE - 2 - (i + 0.5) * (GRID_SIZE - 4) / 3,
                       ghost.y * GRID_SIZE + GRID_SIZE - 6
                   );
                   ctx.lineTo(
                       ghost.x * GRID_SIZE + GRID_SIZE - 2 - (i + 1) * (GRID_SIZE - 4) / 3,
                       ghost.y * GRID_SIZE + GRID_SIZE - 2
                   );
               }
               
               ctx.lineTo(ghost.x * GRID_SIZE + 2, ghost.y * GRID_SIZE + GRID_SIZE - 2);
               ctx.closePath();
               ctx.fill();

               // Ghost eyes
               ctx.fillStyle = '#fff';
               ctx.fillRect(ghost.x * GRID_SIZE + 5, ghost.y * GRID_SIZE + 6, 3, 4);
               ctx.fillRect(ghost.x * GRID_SIZE + 12, ghost.y * GRID_SIZE + 6, 3, 4);
               ctx.fillStyle = '#000';
               ctx.fillRect(ghost.x * GRID_SIZE + 6, ghost.y * GRID_SIZE + 7, 1, 2);
               ctx.fillRect(ghost.x * GRID_SIZE + 13, ghost.y * GRID_SIZE + 7, 1, 2);
           });

           // Draw level transition message (only for level complete)
           if (game.gamePaused && game.gameRunning && game.lives > 0 && dots.length === 0) {
               ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
               ctx.fillRect(0, 0, canvas.width, canvas.height);
               ctx.fillStyle = '#ffff00';
               ctx.font = 'bold 24px Arial';
               ctx.textAlign = 'center';
               ctx.fillText(`Level ${game.level}!`, canvas.width/2, canvas.height/2);
               ctx.font = '16px Arial';
               ctx.fillText('Get Ready!', canvas.width/2, canvas.height/2 + 30);
           }
           
           // Draw manual pause overlay
           if (game.gamePaused && game.gameRunning && dots.length > 0) {
               ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
               ctx.fillRect(0, 0, canvas.width, canvas.height);
               ctx.fillStyle = '#fff';
               ctx.font = 'bold 24px Arial';
               ctx.textAlign = 'center';
               ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
               ctx.font = '14px Arial';
               ctx.fillText('Press SPACE to continue', canvas.width/2, canvas.height/2 + 30);
           }
       }

       // Game loop
       function gameLoop() {
           if (!game.gameRunning) return;

           if (!game.gamePaused) {
               movePlayer(); // Continuous player movement
               moveGhosts();
               checkCollisions();
           }
           
           draw();
           
           requestAnimationFrame(gameLoop);
       }

       // Update UI
       function updateUI() {
           document.getElementById('currentScore').textContent = game.score.toLocaleString();
           document.getElementById('gameLevel').textContent = game.level;
           document.getElementById('gameLives').textContent = game.lives;
           
           const bestScore = parseInt(localStorage.getItem('pacmanBestScore') || '0');
           if (game.score > bestScore) {
               localStorage.setItem('pacmanBestScore', game.score);
               document.getElementById('bestScore').textContent = game.score.toLocaleString();
           } else {
               document.getElementById('bestScore').textContent = bestScore.toLocaleString();
           }
       }

       // Game over
       function gameOver() {
           game.gameRunning = false;
           game.gamePaused = false;
           
           // Save stats
           saveGameStats();
           
           // Show game over modal
           document.getElementById('finalScore').textContent = game.score.toLocaleString();
           document.getElementById('finalLevel').textContent = game.level;
           document.getElementById('gameOverModal').style.display = 'flex';
           
           trackEvent('game_over', { score: game.score, level: game.level });
       }

       // New game
       function newGame() {
           closeModal();
           document.getElementById('startOverlay').style.display = 'none';
           game.gameStarted = true;
           game.gameRunning = true;
           game.gamePaused = false;
           
           // Ensure maze is initialized
           if (!maze || maze.length === 0) {
               initMaze();
           }
           
           resetGameState();
           createDots();
           createGhosts();
           
           // Update pause button text
           document.getElementById('pauseButton').textContent = '⏸️ Pause';
           
           gameLoop();
           trackEvent('new_game');
       }

       // Toggle pause
       function togglePause() {
           if (!game.gameRunning) return;
           
           game.gamePaused = !game.gamePaused;
           document.getElementById('pauseButton').textContent = game.gamePaused ? '▶️ Resume' : '⏸️ Pause';
       }

       // Close modal
       function closeModal() {
           document.getElementById('gameOverModal').style.display = 'none';
       }

       // Load game stats
       function loadGameStats() {
           const stats = JSON.parse(localStorage.getItem('pacmanGameStats') || '{}');
           document.getElementById('gamesPlayed').textContent = stats.gamesPlayed || 0;
           document.getElementById('totalScore').textContent = (stats.totalScore || 0).toLocaleString();
           document.getElementById('bestStreak').textContent = stats.bestStreak || 0;
           document.getElementById('bestScore').textContent = (parseInt(localStorage.getItem('pacmanBestScore') || '0')).toLocaleString();
       }

       // Save game stats
       function saveGameStats() {
           const stats = JSON.parse(localStorage.getItem('pacmanGameStats') || '{}');
           stats.gamesPlayed = (stats.gamesPlayed || 0) + 1;
           stats.totalScore = (stats.totalScore || 0) + game.score;
           
           localStorage.setItem('pacmanGameStats', JSON.stringify(stats));
           loadGameStats();
       }

       // Show leaderboard
       function showLeaderboard() {
           const scores = JSON.parse(localStorage.getItem('pacmanHighScores') || '[]');
           let message = "🏆 High Scores:\n\n";
           
           if (scores.length === 0) {
               message += "No scores yet.\nBe the first!";
           } else {
               scores.slice(0, 5).forEach((score, index) => {
                   message += `#${index + 1}: ${score.toLocaleString()} pts\n`;
               });
           }
           
           alert(message);
       }

       // Utility Functions
       function showInstructions() {
           alert(`🎯 Pac-Man Deluxe - How to Play

🕹️ Controls:
- Arrow Keys or WASD to move
- Spacebar to pause/resume
- Swipe on mobile devices
- N for new game

🎮 Gameplay:
- Collect all yellow dots to advance levels
- Eat power pellets to make ghosts vulnerable
- Avoid ghosts or lose a life
- Eat vulnerable ghosts for bonus points
- Use tunnels on left/right sides to escape!
- Clear all dots to reach the next level

Good luck! 🍀`);
       }

       function toggleFullscreen() {
           if (!document.fullscreenElement) {
               document.documentElement.requestFullscreen().catch(err => {
                   console.log("Fullscreen not supported");
               });
           } else {
               document.exitFullscreen();
           }
       }

       function shareScore() {
           const text = `🎮 I just scored ${game.score.toLocaleString()} points in Pac-Man Deluxe! Can you beat my score? 🏆`;
           
           if (navigator.share) {
               navigator.share({
                   title: "Pac-Man Deluxe - My Score",
                   text: text,
                   url: window.location.href
               });
           } else {
               navigator.clipboard.writeText(text + " " + window.location.href).then(() => {
                   alert("Score copied to clipboard! Share it with your friends! 📋");
               });
           }
           
           trackEvent("score_shared", { score: game.score });
       }

       // Analytics tracking
       function trackEvent(eventName, parameters = {}) {
           if (typeof gtag !== "undefined") {
               gtag("event", eventName, {
                   custom_parameter_1: parameters,
                   game_name: "pac-man-deluxe",
                   ...parameters
               });
           }
           console.log(`Event: ${eventName}`, parameters);
       }

       // Initialize game when page loads
       document.addEventListener("DOMContentLoaded", () => {
           initGame();
       });

       // Prevent zoom on mobile
       let lastTouchEnd = 0;
       document.addEventListener("touchend", function (event) {
           const now = (new Date()).getTime();
           if (now - lastTouchEnd <= 300) {
               event.preventDefault();
           }
           lastTouchEnd = now;
       }, false);

       // Prevent context menu
       document.addEventListener("contextmenu", e => e.preventDefault());

       console.log("🎮 Pac-Man Deluxe loaded successfully!");
   </script>
</body>
</html>