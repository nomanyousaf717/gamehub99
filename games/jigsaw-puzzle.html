<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jigsaw Puzzle - Free HTML5 Game | GameHub 99</title>
    <meta name="description" content="Play Jigsaw Puzzle for free! Challenge your mind with this addictive puzzle game! Mobile-friendly browser game with no download required.">
    <meta name="keywords" content="jigsaw puzzle, puzzle game, html5 game, free online game, browser game, mobile game">
    <meta name="author" content="GameHub 99">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="game">
    <meta property="og:url" content="https://gamehub99.com/games/jigsaw-puzzle.html">
    <meta property="og:title" content="Jigsaw Puzzle - Free HTML5 Game">
    <meta property="og:description" content="Challenge your mind with this addictive puzzle game!">
    <meta property="og:image" content="https://gamehub99.com/assets/jigsaw-puzzle-og.jpg">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://gamehub99.com/games/jigsaw-puzzle.html">
    <meta property="twitter:title" content="Jigsaw Puzzle - Free HTML5 Game">
    <meta property="twitter:description" content="Challenge your mind with this addictive puzzle game!">
    <meta property="twitter:image" content="https://gamehub99.com/assets/jigsaw-puzzle-og.jpg">

    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Orbitron:wght@700;900&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --dark-gradient: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 100%);
            --accent-color: #00d4ff;
            --success-color: #00ff88;
            --warning-color: #ffaa00;
            --text-primary: #ffffff;
            --text-secondary: #b8c1ec;
            --card-bg: rgba(255, 255, 255, 0.05);
            --card-border: rgba(255, 255, 255, 0.1);
            --shadow-glow: 0 0 40px rgba(0, 212, 255, 0.3);
            --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: "Inter", sans-serif;
            background: var(--dark-gradient);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .ad-container-top, .ad-container-bottom {
            width: 100%;
            min-height: 90px;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 1px solid var(--card-border);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .ad-placeholder {
            width: 728px;
            height: 90px;
            background: linear-gradient(45deg, #333, #555);
            border: 2px dashed #666;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 14px;
            border-radius: 8px;
        }

        .header {
            padding: 1rem 0;
            background: var(--card-bg);
            border-bottom: 1px solid var(--card-border);
            backdrop-filter: blur(10px);
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .game-title {
            font-family: "Orbitron", monospace;
            font-size: 2rem;
            font-weight: 900;
            background: linear-gradient(45deg, var(--accent-color), #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: var(--shadow-glow);
            margin: 0;
        }

        .nav-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .nav-button {
            padding: 0.5rem 1rem;
            background: var(--card-bg);
            color: var(--text-primary);
            text-decoration: none;
            border-radius: 8px;
            border: 1px solid var(--card-border);
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .nav-button:hover {
            background: var(--accent-color);
            border-color: var(--accent-color);
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }

        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1rem;
            display: flex;
            gap: 2rem;
            flex: 1;
        }

        .game-section {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .stats-section {
            display: flex;
            gap: 1rem;
        }

        .stat-box {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 12px;
            padding: 0.8rem 1.2rem;
            text-align: center;
            backdrop-filter: blur(10px);
            min-width: 80px;
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.2rem;
            font-weight: 500;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent-color);
            font-family: "Orbitron", monospace;
        }

        .game-controls {
            display: flex;
            gap: 0.5rem;
        }

        .control-button {
            padding: 0.6rem 1rem;
            background: var(--primary-gradient);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-card);
        }

        .control-button.new-game {
            background: var(--success-color);
        }

        .control-button.pause {
            background: var(--warning-color);
        }

        .game-canvas-container {
            position: relative;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 12px;
            padding: 1rem;
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 500px;
        }

        #gameCanvas {
            border-radius: 8px;
            background: #1a1a2e;
            box-shadow: var(--shadow-card);
            cursor: pointer;
        }

        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        .overlay-content {
            text-align: center;
            padding: 2rem;
            background: var(--card-bg);
            border-radius: 12px;
            border: 1px solid var(--card-border);
            max-width: 400px;
            width: 90%;
        }

        .overlay-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--accent-color);
        }

        .overlay-text {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
            color: var(--text-secondary);
        }

        .start-button {
            padding: 1rem 2rem;
            background: var(--primary-gradient);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }

        .mobile-controls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .mobile-control {
            aspect-ratio: 1;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .mobile-control:hover, .mobile-control:active {
            background: var(--accent-color);
            transform: translateY(-2px);
        }

        .mobile-control.empty {
            visibility: hidden;
        }

        .sidebar {
            flex: 1;
            min-width: 280px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .sidebar-section {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 12px;
            padding: 1.2rem;
            backdrop-filter: blur(10px);
        }

        .sidebar-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.8rem;
            color: var(--accent-color);
        }

        .instructions {
            color: var(--text-secondary);
            line-height: 1.5;
            font-size: 0.9rem;
        }

        .instructions ul {
            margin: 0.8rem 0;
            padding-left: 1.2rem;
        }

        .instructions li {
            margin-bottom: 0.4rem;
        }

        .difficulty-selector {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .difficulty-btn {
            flex: 1;
            padding: 0.5rem;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
        }

        .difficulty-btn.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .loading {
            opacity: 0;
            animation: fadeIn 0.6s ease forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 12px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: var(--accent-color);
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1.5rem;
        }

        .modal-button {
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-button.primary {
            background: var(--primary-gradient);
            color: white;
        }

        .modal-button.secondary {
            background: var(--card-bg);
            color: var(--text-secondary);
            border: 1px solid var(--card-border);
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                padding: 1rem;
            }
            
            .header-content {
                flex-direction: column;
                text-align: center;
                gap: 1rem;
            }
            
            .game-title {
                font-size: 1.5rem;
            }
            
            .nav-buttons {
                justify-content: center;
                flex-wrap: wrap;
            }
            
            .game-header {
                flex-direction: column;
                align-items: stretch;
                text-align: center;
            }
            
            .stats-section {
                justify-content: center;
            }
            
            .game-controls {
                justify-content: center;
            }
            
            .mobile-controls {
                display: grid;
            }
            
            .sidebar {
                order: -1;
            }
            
            .ad-placeholder {
                width: 320px;
                height: 50px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <!-- Top Ad Container -->
    <div class="ad-container-top">
        <div class="ad-placeholder">728x90 Header Advertisement</div>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <h1 class="game-title">🧩 Jigsaw Puzzle</h1>
            <nav class="nav-buttons">
                <a href="/" class="nav-button">🏠 Home</a>
                <a href="/games" class="nav-button">🎮 More Games</a>
                <a href="#" class="nav-button" onclick="showInstructions()">❓ How to Play</a>
                <a href="#" class="nav-button" onclick="toggleFullscreen()">📱 Fullscreen</a>
            </nav>
        </div>
    </header>

    <!-- Main Game Container -->
    <div class="game-container">
        <!-- Game Section -->
        <main class="game-section loading">
            <div class="game-header">
                <div class="stats-section">
                    <div class="stat-box">
                        <div class="stat-label">Moves</div>
                        <div class="stat-value" id="moveCount">0</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Best</div>
                        <div class="stat-value" id="bestMoves">-</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Time</div>
                        <div class="stat-value" id="gameTime">0:00</div>
                    </div>
                </div>
                
                <div class="game-controls">
                    <button class="control-button new-game" onclick="newGame()">🆕 New Game</button>
                    <button class="control-button pause" onclick="togglePause()" id="pauseButton">⏸️ Pause</button>
                    <button class="control-button" onclick="showHint()">💡 Hint</button>
                </div>
            </div>

            <!-- Game Canvas -->
            <div class="game-canvas-container">
                <canvas id="gameCanvas" width="400" height="400"></canvas>
                
                <!-- Start Game Overlay -->
                <div class="game-overlay" id="startOverlay">
                    <div class="overlay-content">
                        <div class="overlay-title">🧩 Jigsaw Puzzle</div>
                        <div class="overlay-text">Drag and drop puzzle pieces to complete the image!</div>
                        <button class="start-button" onclick="startGame()">🎯 Start Game</button>
                    </div>
                </div>
            </div>

            <!-- Mobile Controls -->
            <div class="mobile-controls">
                <div class="mobile-control" onclick="shufflePieces()">🔀</div>
                <div class="mobile-control" onclick="showHint()">💡</div>
                <div class="mobile-control" onclick="newGame()">🆕</div>
            </div>
        </main>

        <!-- Sidebar -->
        <aside class="sidebar loading">
            <div class="sidebar-section">
                <h3 class="sidebar-title">🎯 How to Play</h3>
                <div class="instructions">
                    <p><strong>Challenge your mind with this addictive puzzle game!</strong></p>
                    <ul>
                        <li>Drag pieces to move them around</li>
                        <li>Drop pieces in the correct position</li>
                        <li>Complete the puzzle to win</li>
                        <li>Try to solve it in fewer moves!</li>
                    </ul>
                </div>
                
                <div class="difficulty-selector">
                    <div class="difficulty-btn active" onclick="setDifficulty(3)">3x3</div>
                    <div class="difficulty-btn" onclick="setDifficulty(4)">4x4</div>
                    <div class="difficulty-btn" onclick="setDifficulty(5)">5x5</div>
                </div>
            </div>

            <div class="sidebar-section" style="min-height: 250px; display: flex; align-items: center; justify-content: center;">
                <div style="width: 250px; height: 250px; background: linear-gradient(45deg, #333, #555); border: 2px dashed #666; display: flex; align-items: center; justify-content: center; color: #999; font-size: 14px; border-radius: 8px; text-align: center;">
                    250x250<br>Sidebar Ad
                </div>
            </div>
        </aside>
    </div>

    <!-- Modals -->
    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <div class="modal-title">🎉 Puzzle Complete!</div>
            <div id="gameOverStats">
                <p>Congratulations! You solved the puzzle!</p>
                <p>Moves: <span id="finalMoves">0</span></p>
                <p>Time: <span id="finalTime">0:00</span></p>
            </div>
            <div class="modal-buttons">
                <button class="modal-button primary" onclick="newGame(); hideModal('gameOverModal')">🆕 New Game</button>
                <button class="modal-button secondary" onclick="hideModal('gameOverModal')">❌ Close</button>
            </div>
        </div>
    </div>

    <div class="modal" id="instructionsModal">
        <div class="modal-content">
            <div class="modal-title">📖 Instructions</div>
            <div style="text-align: left; margin: 1rem 0;">
                <h4>How to Play:</h4>
                <ul style="margin-left: 1rem;">
                    <li>Click and drag puzzle pieces to move them</li>
                    <li>Drop pieces near their correct position to snap them in place</li>
                    <li>Complete the entire puzzle to win</li>
                    <li>Try to solve it with the fewest moves possible</li>
                </ul>
                <h4>Tips:</h4>
                <ul style="margin-left: 1rem;">
                    <li>Start with corner and edge pieces</li>
                    <li>Look for distinctive colors and patterns</li>
                    <li>Use the hint button if you get stuck</li>
                    <li>Challenge yourself with harder difficulties</li>
                </ul>
            </div>
            <div class="modal-buttons">
                <button class="modal-button primary" onclick="hideModal('instructionsModal')">Got it!</button>
            </div>
        </div>
    </div>

    <!-- Bottom Ad Container -->
    <div class="ad-container-bottom">
        <div class="ad-placeholder">728x90 Footer Advertisement</div>
    </div>

    <script>
        // Game State
        const game = {
            canvas: null,
            ctx: null,
            pieces: [],
            gridSize: 3,
            pieceSize: 0,
            moveCount: 0,
            bestMoves: localStorage.getItem("jigsawBestMoves") || null,
            gameRunning: false,
            gamePaused: false,
            gameStartTime: null,
            gameTime: 0,
            selectedPiece: null,
            dragOffset: { x: 0, y: 0 },
            isDragging: false,
            snapDistance: 30,
            gameImage: null
        };

        // Puzzle pieces data
        const puzzleImages = [
            { 
                colors: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE'],
                pattern: 'gradient'
            },
            {
                colors: ['#FF9FF3', '#54A0FF', '#5F27CD', '#00D2D3', '#FF9F43', '#10AC84', '#EE5A24', '#0074D9', '#B33771'],
                pattern: 'geometric'
            }
        ];

        // Initialize game
        function initGame() {
            game.canvas = document.getElementById("gameCanvas");
            game.ctx = game.canvas.getContext("2d");
            
            // Set canvas size
            resizeCanvas();
            
            // Load best score
            if (game.bestMoves) {
                document.getElementById("bestMoves").textContent = game.bestMoves;
            }
            
            // Generate puzzle image
            generatePuzzleImage();
            
            // Setup event listeners
            setupEventListeners();
            
            // Draw initial state
            drawCanvas();
        }

        function resizeCanvas() {
            const container = document.querySelector('.game-canvas-container');
            const containerWidth = container.clientWidth - 32; // Account for padding
            const containerHeight = container.clientHeight - 32;
            const size = Math.min(containerWidth, containerHeight, 500);
            
            game.canvas.width = size;
            game.canvas.height = size;
            game.pieceSize = size / game.gridSize;
        }

        function generatePuzzleImage() {
            const imageData = puzzleImages[Math.floor(Math.random() * puzzleImages.length)];
            game.gameImage = createColorfulImage(imageData);
        }

        function createColorfulImage(imageData) {
            const canvas = document.createElement('canvas');
            canvas.width = game.canvas.width;
            canvas.height = game.canvas.height;
            const ctx = canvas.getContext('2d');
            
            if (imageData.pattern === 'gradient') {
                // Create gradient pattern
                for (let row = 0; row < game.gridSize; row++) {
                    for (let col = 0; col < game.gridSize; col++) {
                        const x = col * game.pieceSize;
                        const y = row * game.pieceSize;
                        const colorIndex = (row * game.gridSize + col) % imageData.colors.length;
                        
                        const gradient = ctx.createLinearGradient(x, y, x + game.pieceSize, y + game.pieceSize);
                        gradient.addColorStop(0, imageData.colors[colorIndex]);
                        gradient.addColorStop(1, imageData.colors[(colorIndex + 1) % imageData.colors.length]);
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(x, y, game.pieceSize, game.pieceSize);
                        
                        // Add some decorative elements
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.beginPath();
                        ctx.arc(x + game.pieceSize/2, y + game.pieceSize/2, game.pieceSize/4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            } else {
                // Create geometric pattern
                for (let row = 0; row < game.gridSize; row++) {
                    for (let col = 0; col < game.gridSize; col++) {
                        const x = col * game.pieceSize;
                        const y = row * game.pieceSize;
                        const colorIndex = (row * game.gridSize + col) % imageData.colors.length;
                        
                        ctx.fillStyle = imageData.colors[colorIndex];
                        ctx.fillRect(x, y, game.pieceSize, game.pieceSize);
                        
                        // Add geometric shapes
                        ctx.fillStyle = imageData.colors[(colorIndex + 2) % imageData.colors.length];
                        if ((row + col) % 2 === 0) {
                            // Triangle
                            ctx.beginPath();
                            ctx.moveTo(x + game.pieceSize/2, y + 10);
                            ctx.lineTo(x + 10, y + game.pieceSize - 10);
                            ctx.lineTo(x + game.pieceSize - 10, y + game.pieceSize - 10);
                            ctx.closePath();
                            ctx.fill();
                        } else {
                            // Circle
                            ctx.beginPath();
                            ctx.arc(x + game.pieceSize/2, y + game.pieceSize/2, game.pieceSize/3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }
            
            return canvas;
        }

        function setupEventListeners() {
            // Keyboard controls
            document.addEventListener("keydown", handleKeyPress);
            
            // Mouse controls
            game.canvas.addEventListener("mousedown", handleMouseDown);
            game.canvas.addEventListener("mousemove", handleMouseMove);
            game.canvas.addEventListener("mouseup", handleMouseUp);
            
            // Touch controls
            game.canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
            game.canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
            game.canvas.addEventListener("touchend", handleTouchEnd, { passive: false });
            
            // Window resize
            window.addEventListener("resize", () => {
                resizeCanvas();
                drawCanvas();
            });
        }

        function startGame() {
            document.getElementById("startOverlay").style.display = "none";
            game.gameRunning = true;
            game.gameStartTime = Date.now();
            game.moveCount = 0;
            game.gameTime = 0;
            
            createPuzzlePieces();
            shufflePieces();
            startTimer();
            drawCanvas();
            
            // Track game start
            trackEvent("game_started", { difficulty: game.gridSize + "x" + game.gridSize });
        }

        function createPuzzlePieces() {
            game.pieces = [];
            
            for (let row = 0; row < game.gridSize; row++) {
                for (let col = 0; col < game.gridSize; col++) {
                    const piece = {
                        id: row * game.gridSize + col,
                        correctRow: row,
                        correctCol: col,
                        currentRow: row,
                        currentCol: col,
                        x: col * game.pieceSize,
                        y: row * game.pieceSize,
                        correctX: col * game.pieceSize,
                        correctY: row * game.pieceSize,
                        isCorrect: true
                    };
                    game.pieces.push(piece);
                }
				}
   }

   function shufflePieces() {
       // Fisher-Yates shuffle algorithm
       for (let i = game.pieces.length - 1; i > 0; i--) {
           const j = Math.floor(Math.random() * (i + 1));
           
           // Swap pieces
           const tempX = game.pieces[i].x;
           const tempY = game.pieces[i].y;
           const tempRow = game.pieces[i].currentRow;
           const tempCol = game.pieces[i].currentCol;
           
           game.pieces[i].x = game.pieces[j].x;
           game.pieces[i].y = game.pieces[j].y;
           game.pieces[i].currentRow = game.pieces[j].currentRow;
           game.pieces[i].currentCol = game.pieces[j].currentCol;
           
           game.pieces[j].x = tempX;
           game.pieces[j].y = tempY;
           game.pieces[j].currentRow = tempRow;
           game.pieces[j].currentCol = tempCol;
       }
       
       // Update correct status
       game.pieces.forEach(piece => {
           piece.isCorrect = (piece.currentRow === piece.correctRow && piece.currentCol === piece.correctCol);
       });
   }

   function handleMouseDown(e) {
       if (!game.gameRunning || game.gamePaused) return;
       
       const rect = game.canvas.getBoundingClientRect();
       const x = e.clientX - rect.left;
       const y = e.clientY - rect.top;
       
       const piece = getPieceAt(x, y);
       if (piece) {
           game.selectedPiece = piece;
           game.isDragging = true;
           game.dragOffset.x = x - piece.x;
           game.dragOffset.y = y - piece.y;
           game.canvas.style.cursor = 'grabbing';
       }
   }

   function handleMouseMove(e) {
       if (!game.isDragging || !game.selectedPiece) return;
       
       const rect = game.canvas.getBoundingClientRect();
       const x = e.clientX - rect.left;
       const y = e.clientY - rect.top;
       
       game.selectedPiece.x = x - game.dragOffset.x;
       game.selectedPiece.y = y - game.dragOffset.y;
       
       drawCanvas();
   }

   function handleMouseUp(e) {
       if (!game.isDragging || !game.selectedPiece) return;
       
       const rect = game.canvas.getBoundingClientRect();
       const x = e.clientX - rect.left;
       const y = e.clientY - rect.top;
       
       handlePieceDrop(x - game.dragOffset.x, y - game.dragOffset.y);
       
       game.isDragging = false;
       game.selectedPiece = null;
       game.canvas.style.cursor = 'default';
   }

   function handleTouchStart(e) {
       e.preventDefault();
       const touch = e.touches[0];
       const rect = game.canvas.getBoundingClientRect();
       const x = touch.clientX - rect.left;
       const y = touch.clientY - rect.top;
       
       const piece = getPieceAt(x, y);
       if (piece) {
           game.selectedPiece = piece;
           game.isDragging = true;
           game.dragOffset.x = x - piece.x;
           game.dragOffset.y = y - piece.y;
       }
   }

   function handleTouchMove(e) {
       e.preventDefault();
       if (!game.isDragging || !game.selectedPiece) return;
       
       const touch = e.touches[0];
       const rect = game.canvas.getBoundingClientRect();
       const x = touch.clientX - rect.left;
       const y = touch.clientY - rect.top;
       
       game.selectedPiece.x = x - game.dragOffset.x;
       game.selectedPiece.y = y - game.dragOffset.y;
       
       drawCanvas();
   }

   function handleTouchEnd(e) {
       e.preventDefault();
       if (!game.isDragging || !game.selectedPiece) return;
       
       const touch = e.changedTouches[0];
       const rect = game.canvas.getBoundingClientRect();
       const x = touch.clientX - rect.left;
       const y = touch.clientY - rect.top;
       
       handlePieceDrop(x - game.dragOffset.x, y - game.dragOffset.y);
       
       game.isDragging = false;
       game.selectedPiece = null;
   }

   function getPieceAt(x, y) {
       // Check pieces in reverse order (top to bottom)
       for (let i = game.pieces.length - 1; i >= 0; i--) {
           const piece = game.pieces[i];
           if (x >= piece.x && x < piece.x + game.pieceSize &&
               y >= piece.y && y < piece.y + game.pieceSize) {
               return piece;
           }
       }
       return null;
   }

   function handlePieceDrop(dropX, dropY) {
       if (!game.selectedPiece) return;
       
       // Find the closest valid position
       const closestPosition = findClosestPosition(dropX, dropY);
       
       if (closestPosition) {
           // Check if position is occupied
           const occupyingPiece = game.pieces.find(p => 
               p !== game.selectedPiece && 
               p.currentRow === closestPosition.row && 
               p.currentCol === closestPosition.col
           );
           
           if (occupyingPiece) {
               // Swap pieces
               swapPieces(game.selectedPiece, occupyingPiece);
           } else {
               // Move piece to empty position
               movePieceToPosition(game.selectedPiece, closestPosition);
           }
           
           game.moveCount++;
           updateMoveCount();
           
           // Check if puzzle is solved
           if (isPuzzleSolved()) {
               endGame(true);
           }
       } else {
           // Snap back to original position
           snapPieceToGrid(game.selectedPiece);
       }
       
       drawCanvas();
   }

   function findClosestPosition(x, y) {
       const col = Math.round(x / game.pieceSize);
       const row = Math.round(y / game.pieceSize);
       
       // Check if position is within bounds
       if (row >= 0 && row < game.gridSize && col >= 0 && col < game.gridSize) {
           const gridX = col * game.pieceSize;
           const gridY = row * game.pieceSize;
           const distance = Math.sqrt((x - gridX) ** 2 + (y - gridY) ** 2);
           
           if (distance <= game.snapDistance) {
               return { row, col, x: gridX, y: gridY };
           }
       }
       
       return null;
   }

   function swapPieces(piece1, piece2) {
       const tempRow = piece1.currentRow;
       const tempCol = piece1.currentCol;
       const tempX = piece1.x;
       const tempY = piece1.y;
       
       piece1.currentRow = piece2.currentRow;
       piece1.currentCol = piece2.currentCol;
       piece1.x = piece2.x;
       piece1.y = piece2.y;
       
       piece2.currentRow = tempRow;
       piece2.currentCol = tempCol;
       piece2.x = tempX;
       piece2.y = tempY;
       
       // Update correct status
       piece1.isCorrect = (piece1.currentRow === piece1.correctRow && piece1.currentCol === piece1.correctCol);
       piece2.isCorrect = (piece2.currentRow === piece2.correctRow && piece2.currentCol === piece2.correctCol);
   }

   function movePieceToPosition(piece, position) {
       piece.currentRow = position.row;
       piece.currentCol = position.col;
       piece.x = position.x;
       piece.y = position.y;
       
       // Update correct status
       piece.isCorrect = (piece.currentRow === piece.correctRow && piece.currentCol === piece.correctCol);
   }

   function snapPieceToGrid(piece) {
       piece.x = piece.currentCol * game.pieceSize;
       piece.y = piece.currentRow * game.pieceSize;
   }

   function isPuzzleSolved() {
       return game.pieces.every(piece => piece.isCorrect);
   }

   function drawCanvas() {
       const ctx = game.ctx;
       
       // Clear canvas
       ctx.clearRect(0, 0, game.canvas.width, game.canvas.height);
       
       // Draw background grid
       drawGrid();
       
       // Draw pieces (non-selected first)
       game.pieces.forEach(piece => {
           if (piece !== game.selectedPiece) {
               drawPiece(piece);
           }
       });
       
       // Draw selected piece last (on top)
       if (game.selectedPiece) {
           drawPiece(game.selectedPiece, true);
       }
   }

   function drawGrid() {
       const ctx = game.ctx;
       
       ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
       ctx.lineWidth = 1;
       
       // Draw vertical lines
       for (let i = 0; i <= game.gridSize; i++) {
           const x = i * game.pieceSize;
           ctx.beginPath();
           ctx.moveTo(x, 0);
           ctx.lineTo(x, game.canvas.height);
           ctx.stroke();
       }
       
       // Draw horizontal lines
       for (let i = 0; i <= game.gridSize; i++) {
           const y = i * game.pieceSize;
           ctx.beginPath();
           ctx.moveTo(0, y);
           ctx.lineTo(game.canvas.width, y);
           ctx.stroke();
       }
   }

   function drawPiece(piece, isSelected = false) {
       const ctx = game.ctx;
       
       // Save context
       ctx.save();
       
       // Calculate source position in the original image
       const sourceX = piece.correctCol * game.pieceSize;
       const sourceY = piece.correctRow * game.pieceSize;
       
       // Draw piece shadow if selected
       if (isSelected) {
           ctx.shadowColor = 'rgba(0, 212, 255, 0.5)';
           ctx.shadowBlur = 10;
           ctx.shadowOffsetX = 2;
           ctx.shadowOffsetY = 2;
       }
       
       // Draw the piece
       ctx.drawImage(
           game.gameImage,
           sourceX, sourceY, game.pieceSize, game.pieceSize,
           piece.x, piece.y, game.pieceSize, game.pieceSize
       );
       
       // Draw border
       ctx.strokeStyle = piece.isCorrect ? '#00ff88' : (isSelected ? '#00d4ff' : 'rgba(255, 255, 255, 0.3)');
       ctx.lineWidth = piece.isCorrect ? 3 : (isSelected ? 2 : 1);
       ctx.strokeRect(piece.x, piece.y, game.pieceSize, game.pieceSize);
       
       // Draw correct indicator
       if (piece.isCorrect) {
           ctx.fillStyle = 'rgba(0, 255, 136, 0.2)';
           ctx.fillRect(piece.x, piece.y, game.pieceSize, game.pieceSize);
           
           // Draw checkmark
           ctx.strokeStyle = '#00ff88';
           ctx.lineWidth = 3;
           ctx.beginPath();
           ctx.moveTo(piece.x + game.pieceSize * 0.3, piece.y + game.pieceSize * 0.5);
           ctx.lineTo(piece.x + game.pieceSize * 0.45, piece.y + game.pieceSize * 0.65);
           ctx.lineTo(piece.x + game.pieceSize * 0.7, piece.y + game.pieceSize * 0.35);
           ctx.stroke();
       }
       
       // Restore context
       ctx.restore();
   }

   function startTimer() {
       const timer = setInterval(() => {
           if (!game.gameRunning || game.gamePaused) return;
           
           const elapsed = Math.floor((Date.now() - game.gameStartTime) / 1000);
           game.gameTime = elapsed;
           updateGameTime();
           
           if (!game.gameRunning) {
               clearInterval(timer);
           }
       }, 1000);
   }

   function updateMoveCount() {
       document.getElementById("moveCount").textContent = game.moveCount;
   }

   function updateGameTime() {
       const minutes = Math.floor(game.gameTime / 60);
       const seconds = game.gameTime % 60;
       document.getElementById("gameTime").textContent = 
           `${minutes}:${seconds.toString().padStart(2, '0')}`;
   }

   function newGame() {
       // Reset game state
       game.gameRunning = false;
       game.gamePaused = false;
       game.moveCount = 0;
       game.gameTime = 0;
       game.selectedPiece = null;
       game.isDragging = false;
       
       // Update UI
       updateMoveCount();
       updateGameTime();
       document.getElementById("pauseButton").textContent = "⏸️ Pause";
       
       // Generate new puzzle
       generatePuzzleImage();
       
       // Show start overlay
       document.getElementById("startOverlay").style.display = "flex";
       
       // Clear canvas
       drawCanvas();
       
       trackEvent("new_game", { difficulty: game.gridSize + "x" + game.gridSize });
   }

   function togglePause() {
       if (!game.gameRunning) return;
       
       game.gamePaused = !game.gamePaused;
       const pauseButton = document.getElementById("pauseButton");
       
       if (game.gamePaused) {
           pauseButton.textContent = "▶️ Resume";
           drawPauseOverlay();
       } else {
           pauseButton.textContent = "⏸️ Pause";
           drawCanvas();
       }
       
       trackEvent("game_paused", { paused: game.gamePaused });
   }

   function drawPauseOverlay() {
       const ctx = game.ctx;
       
       // Draw semi-transparent overlay
       ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
       ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);
       
       // Draw pause text
       ctx.fillStyle = '#ffffff';
       ctx.font = 'bold 48px Inter';
       ctx.textAlign = 'center';
       ctx.fillText('⏸️', game.canvas.width / 2, game.canvas.height / 2 - 20);
       
       ctx.font = 'bold 24px Inter';
       ctx.fillText('PAUSED', game.canvas.width / 2, game.canvas.height / 2 + 30);
       
       ctx.font = '16px Inter';
       ctx.fillText('Click Resume to continue', game.canvas.width / 2, game.canvas.height / 2 + 60);
   }

   function endGame(won) {
       game.gameRunning = false;
       
       if (won) {
           // Update best score
           if (!game.bestMoves || game.moveCount < game.bestMoves) {
               game.bestMoves = game.moveCount;
               localStorage.setItem("jigsawBestMoves", game.bestMoves);
               document.getElementById("bestMoves").textContent = game.bestMoves;
           }
           
           // Show game over modal
           document.getElementById("finalMoves").textContent = game.moveCount;
           const minutes = Math.floor(game.gameTime / 60);
           const seconds = game.gameTime % 60;
           document.getElementById("finalTime").textContent = 
               `${minutes}:${seconds.toString().padStart(2, '0')}`;
           
           showModal("gameOverModal");
           
           trackEvent("game_completed", {
               moves: game.moveCount,
               time: game.gameTime,
               difficulty: game.gridSize + "x" + game.gridSize
           });
       }
   }

   function showHint() {
       if (!game.gameRunning || game.gamePaused) return;
       
       // Find a piece that's not in the correct position
       const incorrectPiece = game.pieces.find(piece => !piece.isCorrect);
       
       if (incorrectPiece) {
           // Highlight the piece and its correct position
           const ctx = game.ctx;
           
           // Highlight current position
           ctx.strokeStyle = '#ffaa00';
           ctx.lineWidth = 4;
           ctx.strokeRect(incorrectPiece.x, incorrectPiece.y, game.pieceSize, game.pieceSize);
           
           // Highlight correct position
           ctx.strokeStyle = '#00ff88';
           ctx.setLineDash([10, 5]);
           ctx.strokeRect(incorrectPiece.correctX, incorrectPiece.correctY, game.pieceSize, game.pieceSize);
           ctx.setLineDash([]);
           
           // Clear hint after 2 seconds
           setTimeout(() => {
               drawCanvas();
           }, 2000);
           
           trackEvent("hint_used", { difficulty: game.gridSize + "x" + game.gridSize });
       }
   }

   function setDifficulty(size) {
       game.gridSize = size;
       game.pieceSize = game.canvas.width / game.gridSize;
       
       // Update difficulty buttons
       document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
       event.target.classList.add('active');
       
       // Generate new puzzle
       generatePuzzleImage();
       newGame();
       
       trackEvent("difficulty_changed", { new_difficulty: size + "x" + size });
   }

   function handleKeyPress(e) {
       const keyMap = {
           "KeyN": newGame,
           "Space": togglePause,
           "KeyH": showHint,
           "Escape": () => hideModal('instructionsModal')
       };
       
       if (keyMap[e.code]) {
           e.preventDefault();
           keyMap[e.code]();
       }
   }

   // Modal functions
   function showModal(modalId) {
       document.getElementById(modalId).classList.add('show');
   }

   function hideModal(modalId) {
       document.getElementById(modalId).classList.remove('show');
   }

   function showInstructions() {
       showModal('instructionsModal');
   }

   // Utility functions
   function toggleFullscreen() {
       if (!document.fullscreenElement) {
           document.documentElement.requestFullscreen().catch(() => {
               alert('Fullscreen not supported on this device');
           });
       } else {
           document.exitFullscreen();
       }
   }

   function trackEvent(eventName, parameters = {}) {
       // Analytics tracking (replace with your analytics service)
       if (typeof gtag !== 'undefined') {
           gtag('event', eventName, parameters);
       }
       console.log('Event:', eventName, parameters);
   }

   // Initialize game when page loads
   document.addEventListener("DOMContentLoaded", () => {
       initGame();
       
       // Add loading animation completion
       setTimeout(() => {
           document.querySelectorAll('.loading').forEach(el => {
               el.style.opacity = '1';
           });
       }, 100);
   });

   // Handle visibility change (pause game when tab is hidden)
   document.addEventListener('visibilitychange', () => {
       if (document.hidden && game.gameRunning && !game.gamePaused) {
           togglePause();
       }
   });
   </script>
</body>
</html>